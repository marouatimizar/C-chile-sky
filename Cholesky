.cholesky.h

#ifndef CHOLESKY_H
#define CHOLESKY_H

#include <vector>

class Cholesky
{
public:
    // Compute the Cholesky decomposition A = L * L^T
    void compute(const std::vector<std::vector<double>>& A);

    // Display results
    void printL() const;
    void printLT() const;

private:
    std::vector<std::vector<double>> L;   // lower triangular matrix
};

#endif

.cholesky.cpp

Commentaires numérotés exactement comme ton prof :

#include "cholesky.h"
#include <iostream>
#include <cmath>
using namespace std;

void Cholesky::compute(const vector<vector<double>>& A)
{
    int n = A.size();
    L.assign(n, vector<double>(n, 0.0));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= i; j++)
        {
            // Compute 1: calculate summation term
            double sum = 0.0;
            for (int k = 0; k < j; k++)
                sum += L[i][k] * L[j][k];

            // Compute 2: diagonal element
            if (i == j)
            {
                L[i][j] = sqrt(A[i][i] - sum);
            }
            else
            {
                // Compute 3: non-diagonal element
                L[i][j] = (A[i][j] - sum) / L[j][j];
            }
        }
    }
}

void Cholesky::printL() const
{
    cout << "\nMatrix L:\n";
    for (auto& row : L)
    {
        for (auto val : row)
            cout << val << "\t";
        cout << endl;
    }
}

void Cholesky::printLT() const
{
    cout << "\nMatrix L^T:\n";
    int n = L.size();
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            cout << L[j][i] << "\t";
        cout << endl;
    }
}

.main.cpp

#include "cholesky.h"
#include <vector>
using namespace std;

int main()
{
    vector<vector<double>> A = {
        {4, 12, -16},
        {12, 37, -43},
        {-16, -43, 98}
    };

    Cholesky ch;
    ch.compute(A);

    ch.printL();
    ch.printLT();

    return 0;
}
